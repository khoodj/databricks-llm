from .llm import SQL_LLM, PDF_SQL_LLM
from src.pipelines.rag_chain import RAGChain
from langchain_core.tools import tool
from langchain.chains.sql_database.query import create_sql_query_chain
from langchain_community.vectorstores import FAISS
from langchain_core.prompts import ChatPromptTemplate, PromptTemplate
from langchain_core.output_parsers import StrOutputParser
from langchain_core.runnables import RunnablePassthrough
from langchain_experimental.tools import PythonREPLTool
from langchain_community.tools.sql_database.tool import (
    InfoSQLDatabaseTool,
    ListSQLDatabaseTool,
    QuerySQLCheckerTool,
    QuerySQLDataBaseTool,
)
from operator import itemgetter

from sqlalchemy import create_engine
from datetime import datetime
from typing import *

from .structured_output import (
    SQLQuery,
    ExtractSQLQueryDetails,
    IsExactMatchFilterQuery,
    FilePath,
)
from .db import LangchainDB
from ..prompts.prompt import *

import os
import yaml
import pandas as pd
import math
import sqlite3

with open("./conf/config.yaml", "r") as file:
    config = yaml.safe_load(file)


class SQLCustomTools(SQL_LLM, LangchainDB):
    @staticmethod
    @tool
    def create_sql_command(question: str) -> str:
        """A tool to create SQL queries from a user's question. ALL SQL queries MUST be generated using this tool!

        Args:
            question (str): A user's question related to the contents of the SQL database.

        Returns:
            str: A SQL query
        """
        query_object_chain = create_sql_query_chain(
            SQL_LLM.get_llm(), LangchainDB.db, k=config["sql_max_rows"]
        ) | SQL_LLM.get_llm().with_structured_output(SQLQuery)

        sql_rev1 = query_object_chain.invoke({"question": question}).sql_query

        # assess if rev1_query strictly filters on a proper noun
        # if yes, create an agent to do the following: (agent must have access to the question and SQL query)
        is_exact_match_query = (
            SQL_LLM.get_llm()
            .with_structured_output(IsExactMatchFilterQuery)
            .invoke(sql_rev1)
            .is_exact_match_query
        )

        sql_rev2 = sql_rev1
        if is_exact_match_query:
            from .agents import SQLUpdateQueryAgent

            # get column name, filter value and table name
            updated_query_response = SQLUpdateQueryAgent.get_agent_executor().invoke(
                {
                    "input": UPDATE_QUERY_PROMPT.format(
                        question=question, sql_query=sql_rev1
                    )
                }
            )["output"]

            sql_rev2 = (
                SQL_LLM.get_llm()
                .with_structured_output(SQLQuery)
                .invoke(updated_query_response)
                .sql_query
            )

        # else return the query as is
        else:
            pass

        return sql_rev2

    @staticmethod
    @tool
    def execute_sql_command(sql_query: str) -> pd.DataFrame:
        """Executes an SQL query and returns the result as a DataFrame. If an \
        empty dataframe is returned, the query was not successful and the SQL query should be regenerated. \
        The SQL query MUST be generated by create_sql_command tool! \
        Do NOT use this tool without consulting the create_sql_command tool first!

        Args:
            sql_query (str): An SQL query generated by create_sql_command tool.

        Returns:
            pd.DataFrame: The result of the SQL query.
        """

        df = pd.DataFrame()

        sql_uri = config["sql_uri"]
        if "sqlite" in sql_uri:
            try:
                # Get the current directory
                current_directory = os.getcwd()

                # Define the database filename
                folder_name = "data/"
                db_filename = "housing.db"

                # Create the full path to the database file
                db_path = os.path.join(current_directory, folder_name, db_filename)
                conn = sqlite3.connect(db_path)

                # Register the custom functions
                conn.create_function("SQRT", 1, math.sqrt)
                conn.create_function("POWER", 2, math.pow)
                conn.create_function("RADIANS", 1, math.radians)
                conn.create_function("ASIN", 1, math.asin)
                conn.create_function("ACOS", 1, math.acos)
                conn.create_function("SIN", 1, math.sin)
                conn.create_function("COS", 1, math.cos)

                # reading the dataframe
                df = pd.read_sql(sql_query, conn)
            except Exception as e:
                # return an empty dataframe
                print(e)
                df = pd.DataFrame()
            finally:
                conn.close()

        else:
            try:
                engine = create_engine(config["sql_uri"], echo=False)
                df = pd.read_sql(sql_query, engine)
            except Exception as e:
                # return an empty dataframe
                print(e)
                df = pd.DataFrame()
            finally:
                engine.dispose()

        return df

    @staticmethod
    @tool
    def plot_graph(sql_query: str, question: str) -> str:
        """Plots a graph with data from an SQL table loaded into pandas dataframe. If an empty string is returned, the graph creation was not successful. The SQL query MUST be generated by create_sql_command tool! Do NOT use this tool without consulting the create_sql_command tool first.

        Args:
            sql_query (str): An SQL query to be executed to answer the user's question. It MUST be generated by create_sql_command tool!
            question (str): The user's question question

        Returns:
            str: A relative path to the image that is stored
        """
        img_path = ""

        try:
            # This executes code locally, which can be unsafe
            # I can use this as a tool directly but I want to use my own prompt
            python_repl_tool = PythonREPLTool()

            # creating llm with tools
            coder_llm = SQL_LLM.get_llm().bind_tools([python_repl_tool])

            # creating a chain to execute code
            chain = (
                coder_llm
                | (lambda x: x.tool_calls[0]["args"])
                | python_repl_tool
                | SQL_LLM.get_llm().with_structured_output(FilePath)
            )

            img_path = chain.invoke(
                PLOT_GRAPH_INSTRUCTIONS.format(
                    sql_query=sql_query,
                    question=question,
                    db_path=config.get("sql_uri", ""),
                )
            ).file_path

            img_path = img_path.replace("\n", "")

        except Exception as e:
            print(f"Graph could not be created with error: {e}")

        return img_path

    @staticmethod
    def list_database():
        return ListSQLDatabaseTool(db=LangchainDB.db)

    @staticmethod
    def info_database():
        info_sql_database_tool_description = (
            "Use this tool to identify database table schemas. "
            "Input to this tool is a comma-separated list of tables, output is the "
            "schema and sample rows for those tables. "
            "Be sure that the tables actually exist by calling "
            f"{SQLCustomTools.list_database().name} first! "
            "Example Input: table1, table2, table3. \n\n"
        )
        return InfoSQLDatabaseTool(
            db=LangchainDB.db, description=info_sql_database_tool_description
        )

    @staticmethod
    def sql_query_checker():
        query_sql_checker_tool_description = f"Use this tool to double check if your query is correct before executing it. Always use this tool after creating an SQL query with {SQLCustomTools.create_sql_command.name}"
        return QuerySQLCheckerTool(
            db=LangchainDB.db,
            llm=SQL_LLM.get_llm(),
            description=query_sql_checker_tool_description,
        )


class SQLFilterUniqueValues(SQL_LLM, LangchainDB):
    @staticmethod
    @tool
    def get_filter_column_details(sql_query: str) -> Dict[str, str]:
        """Gets the table name, filtered column and the filtered value in an SQL query. It is only meant to be used on exact match filters.

        Args:
            sql_query (str): An SQL query that contains an exact match filter

        Returns:
            Dict[str, str]: A dictionary containing the column name, filtered value and table name that is undergoing exact match filter.
        """
        filter_details_object = (
            SQL_LLM.get_llm()
            .with_structured_output(ExtractSQLQueryDetails)
            .invoke(sql_query)
        )

        return {
            key: getattr(filter_details_object, key)
            for key in ["column_name", "filtered_value", "table_name"]
        }

    @staticmethod
    @tool
    def find_similar_proper_nouns(
        column_name: str, filtered_value: str, table_name: str
    ) -> List[Optional[str]]:
        """Retrieve a list of unique values from a database column that are similar to a specified filter value.

        Args:
            column_name (str): The column of a database table to get unique values from
            filtered_value (str): The exact match string that is being filtered in the column in the SQL query
            table_name (str): The table name where the column is being filtered on

        Returns:
            List[Optional[str]]: A list of unique values in the column that are similar to the exact match string
        """
        similar_unique_values_ls = []

        try:
            vector_db = FAISS.load_local(
                f"{config['vectordb_folder']}{table_name}_{column_name}",
                embeddings=SQL_LLM.get_embeddings_model(),
                allow_dangerous_deserialization=True,
            )
            retriever = vector_db.as_retriever(search_kwargs={"k": 10})
            similar_unique_values_ls = [
                doc.page_content for doc in retriever.invoke(filtered_value)
            ]
        except Exception as e:
            print("find_similar_proper_nouns function yielded the error:\n", e)

        return similar_unique_values_ls

    @staticmethod
    @tool
    def assess_similar_proper_nouns(
        question: str,
        sql_query: str,
        filter_column_name: str,
        similar_unique_values_ls: List[Optional[str]],
    ) -> str:
        """Returns an SQL query with the correct filtered value(s) in the filtered column. This tool will assess which unique value(s) in the filtered column is appropriate to answer the user's question.

        Args:
            question (str): A user's question
            sql_query (str): An SQL query that potentially has wrong or insufficient filter values in the filter column
            filter_column_name (str): The column name containing the unique values. It must appear in the SQL query.
            similar_unique_values_ls (List[Optional[str]]): A list of unique values in the filter column

        Returns:
            str: An SQL query that has appropriate filter value(s) in the filter column
        """
        # LLM should assess which values in the top k are relevant to the filter value and user question
        assess_chain = (
            ChatPromptTemplate.from_messages(
                [
                    ("system", GENERIC_SYSTEM_PROMPT),
                    ("human", ASSESS_RELEVANT_FILTERS_PROMPT),
                ]
            )
            | SQL_LLM.get_llm()
            | StrOutputParser()
            | SQL_LLM.get_llm().with_structured_output(SQLQuery)
        )

        return assess_chain.invoke(
            {
                "filter_column_name": filter_column_name,
                "question": question,
                "sql_query": sql_query,
                "similar_unique_values_ls": similar_unique_values_ls,
            }
        ).sql_query


class RAGSQLTools(PDF_SQL_LLM):
    @staticmethod
    @tool
    def sql_chain(input: str) -> Tuple[str, List[str]]:
        """Searches an SQL database for information that might be able to answer the user's question

        Args:
            input (str): A user's question

        Returns:
            Tuple[str, List[str]]: The first element is the search result. The second element is a list of graph ids if any graphs are returned from the search
        """
        from .agents import SQLAgent

        # getting response
        response = SQLAgent().get_agent_executor().invoke({"input": input})

        # returning result
        graph_id_ls = []
        if response["intermediate_steps"]:
            for tup in response["intermediate_steps"]:
                if getattr(tup[0], "tool") == "plot_graph":
                    graph_id_ls.append(tup[1])
            return response["output"], graph_id_ls
        else:
            return (
                "There is no relevant information about the user's question in the SQL database",
                graph_id_ls,
            )

    @staticmethod
    @tool
    def rag_chain(input: str) -> str:
        """Searches the vector database for information that might be able answer the user's question

        Args:
            input (str): A user's question

        Returns:
            str: A response to the user's question from searching through a storage of unstructured files
        """
        return RAGChain().output_chain().invoke({"input": input})["answer"]
